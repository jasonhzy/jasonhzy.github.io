<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Apache htaccess]]></title>
      <url>http://jasonhzy.github.io/2016/02/03/apache-htaccess/</url>
      <content type="html"><![CDATA[<blockquote>
<p>&emsp;&emsp;.htaccess文件(或者”分布式配置文件”)提供了针对目录改变配置的方法，即在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。</p>
</blockquote>
<a id="more"></a>
<p>.htaccess编写是用正则的方式，整理分享一下.htaccess 的参数说明:</p>
<pre><code>[F] —— Forbidden(禁止): 命令服务器返回 403 Forbidden错误给用户浏览器
[L] —— Last rule(最后一条规则): 告诉服务器在本条规则执行完后停止重写URL
[N] —— Next(下一条规则): 告诉服务器继续重写，指导所有重写指令都执行过
[G] —— Gone(丢失): 命令服务器返回410 GONE(no longer exists)错误消息
[P] —— Proxy(代理): 告诉服务器通过mod_proxy模块处理用户请求
[C] —— Chain(捆绑): 告诉服务器将当前的规则和前面的规则进行捆绑
[R] —— Redirect(重定向):命令服务器发出重定向消息，以便用户浏览器发出
        rewritten/modified(重写/修改)URL的请求
[NC] —— No Case(不区分大小写): 对客户端请求的URL不区分大小写
[PT] —— Pass Through(放行): 让mod_rewrite模块将重写的URL传回给Apache做进一步处理
[OR] —— Or(逻辑或): 用逻辑“或”将两个表达式连接在一起，如果结果为“真”，则会应用后继的相关规则
[NE] —— No Escape(禁用转义): 命令服务器在输出时禁用转义字符
[NS] —— No Subrequest(禁用子请求): 如果存在内部子请求，则跳过当前命令
[QSA] —— Append Query String(追加查询字符串): 命令服务器在URL末尾追加查询字符串
[S=x] —— Skip(跳过): 如果满足某指定的条件，则跳过后面第x调规则
[E=variable:value] —— Environmental Variable(环境变量): 命令服务器将值value赋给变量variable
[T=MIME-type] —— Mime Type(MIME类型): 声明目标资源所属的MIME类型

# —— 位于行首时表示注释。
- —— 命令Apache“不要”重写URL，例如“xxx.domain.com.* – [F]”
! —— 逻辑非。例如“!string” 将会匹配除了“string”以外的所有字符串
^$ —— 匹配“空字符”、“空行”
-d —— 测试字符串是否是已存在的目录，例如RewriteCond %{REQUEST_FILENAME} !-d
-f —— 测试字符串是否是已存在的文件 例如 RewriteCond %{REQUEST_FILENAME} !-f
-s —— 测试字符串所指文件是否有“非零”值
</code></pre><p>.htaccess文件禁止访问.git、.svn等目录。打开.htaccess文件，添加如下代码：</p>
<pre><code>RewriteEngine on
RewriteRule ^.git - [F,L]
</code></pre><p><strong>Example:</strong></p>
<pre><code>RewriteEngine on 打开引擎
RewriteRule test.html /test.php [L] 
RewriteRule test.html?$ /tianqi.php?s1=&amp;s2=&amp;S3= [QSA,L] 用于多个参数的情况
RewriteRule tianqi-([0-9]+).html /tianqi.php?id=$1 [L]
RewriteCond %{HTTP_HOST} ^www.example.com [NC]  
RewriteRule ^(.*)$ http://example.com/$1 [L,R=301]  
</code></pre><h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><ul>
<li>‘redirect|R [=code]’ (强制重定向 redirect)<br>以http: //thishost[:thisport]/(使新的URL成为一个URI)为前缀的Substitution可以强制性执行一个外部重定向。如果code没有指定，则产生一个HTTP响应代码302(临时性移动)。如果需要使用在300-400范围内的其他响应代码，只需在此指定这个数值即可，另外，还可以使用下列符号名称之一: temp (默认的), permanent,seeother.用它可以把规范化的URL反馈给客户端，如, 重写<code>/~&#39;&#39;为</code>/u/‘’，或对/u/user加上斜杠，等等。<br>注意:在使用这个标记时，必须确保该替换字段是一个有效的URL!否则，它会指向一个无效的位置!并且要记住，此标记本身只是对URL加上<a href="http://thishost[:thisport]/的前缀，重写操作仍然会继续。通常，你会希望停止重写操作而立即重定向，则还需要使用&#39;L&#39;标记" target="_blank" rel="noopener">http://thishost[:thisport]/的前缀，重写操作仍然会继续。通常，你会希望停止重写操作而立即重定向，则还需要使用&#39;L&#39;标记</a>.</li>
<li>‘forbidden|F’ (强制URL为被禁止的 forbidden)<br>强制当前URL为被禁止的，即，立即反馈一个HTTP响应代码403(被禁止的)。使用这个标记，可以链接若干RewriteConds以有条件地阻塞某些URL。</li>
<li>‘gone|G’ (强制URL为已废弃的 gone)<br>强制当前URL为已废弃的，即，立即反馈一个HTTP响应代码410(已废弃的)。使用这个标记，可以标明页面已经被废弃而不存在了.</li>
<li>‘proxy|P’ (强制为代理 proxy)<br>此 标记使替换成分被内部地强制为代理请求，并立即(即重写规则处理立即中断)把处理移交给代理模块。你必须确保此替换串是一个有效的(比如常见的以<a href="http://hostname开头的)能够为Apache代理模块所处理的URI。使用这个标记，可以把某些远程成分映射到本地服务器名称空间，从而增强了ProxyPass指令的功能。" target="_blank" rel="noopener">http://hostname开头的)能够为Apache代理模块所处理的URI。使用这个标记，可以把某些远程成分映射到本地服务器名称空间，从而增强了ProxyPass指令的功能。</a><br>注意:要使用这个功能，代理模块必须编译在Apache服务器中。如果你不能确定，可以检查<code>httpd -l&#39;&#39;的输出中是否有mod_proxy.c。如果有，则mod_rewrite可以使用这个功能；如果没有，则必须启用mod_proxy并重新编译</code>httpd’’程序。</li>
<li>‘last|L’ (最后一个规则 last)<br>立即停止重写操作，并不再应用其他重写规则。它对应于Perl中的last命令或C语言中的break命令。这个标记可以阻止当前已被重写的URL为其后继的规则所重写。举例，使用它可以重写根路径的URL(‘/‘)为实际存在的URL, 比如, ‘/e/www/‘.</li>
<li>‘next|N’ (重新执行 next round)<br>重新执行重写操作(从第一个规则重新开 始).这时再次进行处理的URL已经不是原始的URL了，而是经最后一个重写规则处理的URL。它对应于Perl中的next命令或C语言中的continue命令。<br>此标记可以重新开始重写操作，即立即回到循环的头部。但是要小心，不要制造死循环!</li>
<li>‘chain|C’ (与下一个规则相链接 chained)<br>此标记使当前规则与下一个(其本身又可以与其后继规则相链接的，并可以如此反复的)规则相链接。 它产生这样一个效果:如果一个规则被匹配，通常会继续处理其后继规则，即这个标记不起作用；如果规则不能被匹配，则其后继的链接的规则会被忽略。比如，在执行一个外部重定向时，对一个目录级规则集，你可能需要删除<code>.www&#39;&#39; (此处不应该出现</code>.www’’的’)。</li>
<li>‘type|T=MIME-type’ (强制MIME类型 type)<br>强制目标文件的MIME类型为MIME-type。比如，它可以用于模拟mod_alias中的ScriptAlias指令，以内部地强制被映射目录中的所有文件的MIME类型为<code></code>application/x-httpd-cgi’’.</li>
<li>‘nosubreq|NS’ (仅用于不对内部子请求进行处理 no internal sub-request)<br>在当前请求是一个内部子请求时，此标记强制重写引擎跳过该重写规则。比如，在mod_include试图搜索可能的目录默认文件(index.xxx)时，Apache会内部地产生子请求。对子请求，它不一定有用的，而且如果整个规则集都起作用，它甚至可能会引发错误。所以，可以用这个标记来排除某些规则。<br>根据你的需要遵循以下原则:<br>如果你使用了有CGI脚本的URL前缀，以强制它们由CGI脚本处理，而对子请求处理的出错率(或者开销)很高，在这种情况下，可以使用这个标记。</li>
<li>‘nocase|NC’ (忽略大小写 no case)<br>它使Pattern忽略大小写，即, 在Pattern与当前URL匹配时，’A-Z’ 和’a-z’没有区别。</li>
<li>‘qsappend|QSA’ (追加请求串 query string append)<br>此标记强制重写引擎在已有的替换串中追加一个请求串，而不是简单的替换。如果需要通过重写规则在请求串中增加信息，就可以使用这个标记。</li>
<li>‘noescape|NE’ (在输出中不对URI作转义 no URI escaping)<br>此 标记阻止mod_rewrite对重写结果应用常规的URI转义规则。一般情况下，特殊字符(如’%’, ‘$’, ‘;’等)会被转义为等值的十六进制编码。此标记可以阻止这样的转义，以允许百分号等符号出现在输出中，如： RewriteRule /foo/(.*) /bar?arg=P1\%3d$1 [R,NE] 可以使’/foo/zed’转向到一个安全的请求’/bar?arg=P1=zed’.</li>
<li>‘passthrough|PT’ (移交给下一个处理器 pass through)<br>此标记强制重写引擎将内部结构request_rec中的uri字段设置为filename字段的值，它只是一个小修改，使之能对来自其他URI到文件名翻译器的Alias，ScriptAlias, Redirect等指令的输出进行后续处理。举一个能说明其含义的例子：<br>如果要通过mod_rewrite的重写引擎重写/abc为/def，然后通过mod_alias使/def转变为/ghi，可以这样:<br>  RewriteRule ^/abc(.*) /def$1 [PT]<br>  Alias /def /ghi<br>如果省略了PT标记，虽然mod_rewrite运作正常， 即作为一个使用API的URI到文件名翻译器，它可以重写uri=/abc/…为filename=/def/…，但是，后续的mod_alias在试图作URI到文件名的翻译时，则会失效。<br>注意: 如果需要混合使用不同的包含URI到文件名翻译器的模块时，就必须使用这个标记。混合使用mod_alias和mod_rewrite就是个典型的例子。<br>For Apache hackers<br>如果当前Apache API除了URI到文件名hook之外，还有一个文件名到文件名的hook，就不需要这个标记了! 但是，如果没有这样一个hook，则此标记是唯一的解决方案。Apache Group讨论过这个问题，并在Apache 2.0 版本中会增加这样一个hook。</li>
<li>‘skip|S=num’ (跳过后继的规则 skip)<br>此标记强制重写引擎跳过当前匹配规则后继的num个规则。它可以实现一个伪if-then-else的构造:最后一个规则是then从句，而被跳过的skip=N个规则是else从句.(它和’chain|C’标记是不同的!)</li>
<li>‘env|E=VAR:VAL’ (设置环境变量 environment variable)<br>此标记使环境变量VAR的值为VAL, VAL可以包含可扩展的反向引用的正则表达式$N和%N。此标记可以多次使用以设置多个变量。这些变量可以在其后许多情况下被间接引用，但通常是在XSSI(via or CGI (如$ENV{‘VAR’})中，也可以在后继的RewriteCond指令的pattern中通过%{ENV:VAR}作引用。使用它可以从URL中剥离并记住一些信息。’cookie|CO=NAME:VAL:domain[:lifetime[:path]]’ (设置cookie)它在客户端浏览器上设置一个cookie。 cookie的名称是NAME，其值是VAL。domain字段是该cookie的域，比如’.apache.org’,可选的lifetime是cookie生命期的分钟数，可选的path是cookie的路径。)</li>
</ul>
<h2 id="部分指令格式配置详解"><a href="#部分指令格式配置详解" class="headerlink" title="部分指令格式配置详解"></a>部分指令格式配置详解</h2><p>1.RewriteEngine，用来设置是否启动url rewrite，开启配置即：</p>
<pre><code>RewriteEngine on
</code></pre><p>2.RewriteBase，设置目录级重写的基准URL</p>
<pre><code>RewriteEngine on
RewriteBase /test  #将会重定向到http://example.com/base/xxx
</code></pre><p>3.RewriteCond 和 RewriteRule，表示如果符合某个或某几个条件则执行RewriteCond下面紧邻的RewriteRule语句，例如防盗链</p>
<pre><code>RewriteEngine on
RewriteCond %{HTTP_REFERER} !^$ [NC]
RewriteCond %{HTTP_REFERER} !^https://www.example.com$ [NC]
RewriteRule .(gif|jpg|png|jpeg|bmp)$ https://www.example.com/404.jpg [R,NC]
</code></pre>]]></content>
      
        <categories>
            
            <category> Apache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Apache </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
